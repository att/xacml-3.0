/*
 *
 *          Copyright (c) 2013,2019-2020  AT&T Knowledge Ventures
 *                     SPDX-License-Identifier: MIT
 */
package com.att.research.xacml.std.dom;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.Iterator;

import javax.security.auth.x500.X500Principal;
import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.att.research.xacml.api.Advice;
import com.att.research.xacml.api.Attribute;
import com.att.research.xacml.api.AttributeAssignment;
import com.att.research.xacml.api.AttributeCategory;
import com.att.research.xacml.api.AttributeValue;
import com.att.research.xacml.api.Decision;
import com.att.research.xacml.api.IdReference;
import com.att.research.xacml.api.Identifier;
import com.att.research.xacml.api.MissingAttributeDetail;
import com.att.research.xacml.api.Obligation;
import com.att.research.xacml.api.Response;
import com.att.research.xacml.api.Result;
import com.att.research.xacml.api.SemanticString;
import com.att.research.xacml.api.Status;
import com.att.research.xacml.api.StatusCode;
import com.att.research.xacml.api.StatusDetail;
import com.att.research.xacml.api.XACML3;
import com.att.research.xacml.std.StdMutableResponse;
import com.att.research.xacml.std.StdResponse;
import com.att.research.xacml.std.StdStatusCode;
import com.att.research.xacml.std.datatypes.ExtendedNamespaceContext;
import com.att.research.xacml.std.datatypes.XPathExpressionWrapper;
import com.att.research.xacml.std.json.JSONStructureException;
import com.att.research.xacml.util.MainUtils;

/**
 * DOMResponse is used to convert XML into {@link com.att.research.xacml.api.Response} objects and 
 * {@link com.att.research.xacml.api.Response} objects into XML strings.
 * Instances of this class are never created.
 * The {@link com.att.research.xacml.api.Response} objects returned by this class are instances of
 * {@link com.att.research.xacml.std.StdMutableResponse}.
 * {@link com.att.research.xacml.api.Response} objects are generated by loading a file or XML Node tree representing the Request.
 * In normal product operation this is not used to generate new instances
 * because the PDP generates {@link com.att.research.xacml.std.StdResponse} objects internally.
 * Those objects are converted to XML strings for transmission through the RESTful Web Service
 * using the <code>convert</code> method in this class.
 * 
 * @author car
 * @version $Revision: 1.2 $
 */
public class DOMResponse {
	private static final Logger logger	= LoggerFactory.getLogger(DOMResponse.class);
	
	protected DOMResponse() {
	}
	
	
	
	/**
	 * Creates a new <code>DOMResponse</code> by parsing the given <code>Node</code> representing a XACML Response element.
	 * 
	 * @param nodeResponse the <code>Node</code> representing the XACML Response element
	 * @return a new <code>DOMResponse</code> parsed from the given <code>Node</code>
	 * @throws DOMStructureException if the conversion cannot be made
	 */
	public static Response newInstance(Node nodeResponse) throws DOMStructureException {
		Element	elementResponse		= DOMUtil.getElement(nodeResponse);
		boolean bLenient			= DOMProperties.isLenient();
		
		StdMutableResponse mutableResponse		= new StdMutableResponse();
		
		NodeList children			= elementResponse.getChildNodes();
		int numChildren;
		boolean sawResult			= false;
		if (children != null && (numChildren = children.getLength()) > 0) {
			for (int i = 0 ; i < numChildren ; i++) {
				Node child	= children.item(i);
				if (DOMUtil.isElement(child)) {
					if (DOMUtil.isInNamespace(child, XACML3.XMLNS)&& XACML3.ELEMENT_RESULT.equals(child.getLocalName())) {
						mutableResponse.add(DOMResult.newInstance(child));
						sawResult	= true;
					} else {
						if (!bLenient) {
							throw DOMUtil.newUnexpectedElementException(child, nodeResponse);
						}
					}
				}
			}
		}
		if (!sawResult && !bLenient) {
			throw DOMUtil.newMissingElementException(nodeResponse, XACML3.XMLNS, XACML3.ELEMENT_RESULT);
		}
		
		return new StdResponse(mutableResponse);
	}
	
	/**
	 * Change XACML2 into XACML3
	 * 
	 * @param nodeResponse The response Node to repair
	 * @return true of repaired
	 * @throws DOMStructureException If there is a structure issue
	 */
	public static boolean repair(Node nodeResponse) throws DOMStructureException {
		Element	elementResponse		= DOMUtil.getElement(nodeResponse);
		boolean result				= false;
		
		NodeList children			= elementResponse.getChildNodes();
		int numChildren;
		boolean sawResult			= false;
		if (children != null && (numChildren = children.getLength()) > 0) {
			for (int i = 0 ; i < numChildren ; i++) {
				Node child	= children.item(i);
				if (DOMUtil.isElement(child)) {
					if (DOMUtil.isInNamespace(child, XACML3.XMLNS)&& XACML3.ELEMENT_RESULT.equals(child.getLocalName())) {
						result	= DOMResult.repair(child) || result;
						sawResult	= true;
					} else {
						logger.warn("Unexpected element {}", child.getNodeName());
						elementResponse.removeChild(child);
						result	= true;
					}
				}
			}
		}
		
		if (!sawResult) {
			throw DOMUtil.newMissingElementException(nodeResponse, XACML3.XMLNS, XACML3.ELEMENT_RESULT);
		}
		return result;
	}

	

	public static Response load(String xmlString) throws DOMStructureException {
		Response response = null;
		try (InputStream is = new ByteArrayInputStream(xmlString.getBytes(StandardCharsets.UTF_8))) {
			response = load(is);
		} catch (Exception ex) {
			throw new DOMStructureException("Exception loading String Response: " + ex.getMessage(), ex);
		}
		return response;
	}
	
	
	/**
	 * Read a file containing an XML representation of a Response and parse it into a {@link com.att.research.xacml.api.Response} Object.
	 * This is used only for testing since Responses in the normal environment are generated by the PDP code.
	 * 
	 * @param fileResponse File object to load
	 * @return True of loaded
	 * @throws DOMStructureException If there is a structure issue
	 */
	public static Response load(File fileResponse) throws DOMStructureException {
		try (BufferedReader br = new BufferedReader(new FileReader(fileResponse))) {
			StringBuilder responseString = new StringBuilder();
			String line;
			while ((line = br.readLine()) != null) {
				responseString.append(line);
			}
			return load(responseString.toString());
		} catch (Exception e) {
			throw new DOMStructureException("File: " + fileResponse.getName() + " " + e.getMessage());
		}
	}
	
	/**
	 * Loads a response from java nio Path object.
	 * 
	 * @param fileResponse Path to file to load
	 * @return Response Resulting Response object
	 * @throws DOMStructureException If there is a structure issue
	 */
	public static Response load(Path fileResponse) throws DOMStructureException {
		try {
			return DOMResponse.load(Files.newInputStream(fileResponse));
		} catch (Exception e) {
			throw new DOMStructureException(e);
		}
	}
	
	
	/**
	 * Read a file containing an XML representation of a Response and parse it into a {@link com.att.research.xacml.api.Response} Object.
	 * This is used only for testing since Responses in the normal environment are generated by the PDP code.
	 * 
	 * @param is InputStream
     * @return Response Resulting Response object
     * @throws DOMStructureException If there is a structure issue
	 */
	public static Response load(InputStream is) throws DOMStructureException {
		/*
		 * Get the DocumentBuilderFactory
		 */
		DocumentBuilderFactory documentBuilderFactory	= DocumentBuilderFactory.newInstance();
        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
		documentBuilderFactory.setNamespaceAware(true);
		
		/*
		 * Get the DocumentBuilder
		 */
		DocumentBuilder documentBuilder	= null;
		try {
			documentBuilder	= documentBuilderFactory.newDocumentBuilder();
		} catch (Exception ex) {
			throw new DOMStructureException("Exception creating DocumentBuilder: " + ex.getMessage(), ex);
		}
		
		/*
		 * Parse the XML file
		 */
		Document document	= null;
		Response request	= null;
		try {
			document	= documentBuilder.parse(is);
			if (document == null) {
				throw new Exception("Null document returned");
			}
			
			Node rootNode	= document.getFirstChild();
			if (rootNode == null) {
				throw new Exception("No child in document");
			}
			
			if (DOMUtil.isInNamespace(rootNode, XACML3.XMLNS)) {
				if (XACML3.ELEMENT_RESPONSE.equals(rootNode.getLocalName())) {
					request	= DOMResponse.newInstance(rootNode);
				} else {
					throw DOMUtil.newUnexpectedElementException(rootNode);
				}
			} else {
				throw DOMUtil.newUnexpectedElementException(rootNode);
			}
		} catch (Exception ex) {
			throw new DOMStructureException("Exception loading Response from InputStream: " + ex.getMessage(), ex);
		}
		return request;
	}
	
	
	/**
	 * Convert the {@link com.att.research.xacml.api.Response} into an XML string.
	 * This is used only for debugging.
	 * It assumes that pretty-printing is desired.
	 * 
	 * @param response Response to convert
	 * @return String in XML format
	 * @throws Exception Exception
	 */
	public static String toString(Response response) throws Exception {
		return toString(response, true);
	}
	
	/**
	 * Convert the {@link com.att.research.xacml.api.Response} into an XML string.
	 * This is used only for debugging.
	 * The caller chooses whether to pretty-print or not.
	 * 
	 * @param response Response to convert to string representation
	 * @param prettyPrint <code>true</code> if pretty printing
	 * @return String in XML format
	 * @throws Exception Exception
	 */
	public static String toString(Response response, boolean prettyPrint) throws Exception {
		String outputString = null;
		try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
			DOMResponse.convert(response, os, prettyPrint);
			outputString = new String( os.toByteArray(), StandardCharsets.UTF_8);
		}
		return outputString;
	}
	

	/**
	 * Helper - recursively output StatusCode objects as XML.
	 * 
	 * @param sb StringBuilder object to store
	 * @param statusCode StatusCode object
	 * @param tabCount number of tabs
	 * @param prettyPrint <code>true</code> if pretty printing
	 */
	private static void outputStatusCode(StringBuilder sb, StatusCode statusCode, int tabCount, boolean prettyPrint) {
		StringBuilder prettyPrintString = new StringBuilder();
		if (prettyPrint) {
			prettyPrintString.append("\n");
			for (int i = 0; i < tabCount; i++) {
				prettyPrintString.append("\t");
			}
		}
		
		sb.append(prettyPrintString);
		sb.append("<StatusCode");
		
		if (statusCode.getStatusCodeValue() != null) {
			sb.append(" Value=\"" + statusCode.getStatusCodeValue().stringValue() + "\"");
		} 
		
		if (statusCode.getChild() == null) {
			// no child code, so finish off the StatusCode element now
			sb.append("/>");
		} else {
			// there is a child, so need to use the two-part notation for this StatusCode
			sb.append(">");
			outputStatusCode(sb, statusCode.getChild(), tabCount + 1, prettyPrint);
			sb.append(prettyPrintString);
			sb.append("</StatusCode>");
		}
	}
	
	/**
	 * Helper: When outputting as XML string, get the value of a Value (within an AttributeValue) object as a String.
	 * Most of these objects are SemanticStrings, but some are not and we cannot assume that in the places where we need to generate the output.
	 * 
	 * @param obj Object
	 * @return String  String value
	 * @throws JSONStructureException Structure exception
	 * @throws DOMStructureException Structure exception 
	 */
	private static String outputValueValue(Object obj) throws DOMStructureException {
		if (obj instanceof String ||
				obj instanceof Boolean ||
				obj instanceof Integer ||
				obj instanceof BigInteger ) {
			return obj.toString();
		} else if (obj instanceof Double) {
			Double d = (Double)obj;
			if (d == Double.NaN) {
				return "NaN";
			} else if (d == Double.POSITIVE_INFINITY) {
				return "INF";
			} else if (d == Double.NEGATIVE_INFINITY) {
				return "-INF";
			}
			return obj.toString();
		} else if (obj instanceof SemanticString) {
			return ((SemanticString)obj).stringValue();
		} else if (obj instanceof X500Principal ||
				obj instanceof URI) {
			// something is very weird with X500Principal data type.  If left on its own the output is a map that includes encoding.
			return obj.toString();
		} else if (obj instanceof XPathExpressionWrapper) {

			XPathExpressionWrapper xw = (XPathExpressionWrapper) obj;

			return xw.getPath();
		} else {
			throw new DOMStructureException("Unhandled data type='" + obj.getClass().getName() + "'");
		}
	}
	
	
	/**
	 * Helper: When outputting as XML string, extract any Namespace info from an AttributeValue.Value.Value object.
	 * This must be done separately from getting the Value as a String because this info is put as an attribute in the surrounding element.
	 * Currently only applies to XPathExpressionWrappers.
	 * 
	 * @param valueObject input value Object
	 * @return String namespace
	 */
	private static String getNamespaces(Object valueObject) {
		StringBuilder returnString = new StringBuilder();
		if ( ! (valueObject instanceof XPathExpressionWrapper)) {
			// value is not XPathExpression, so has no Namespace info in it
			return returnString.toString();
		}
		XPathExpressionWrapper xw = (XPathExpressionWrapper) valueObject;
		
		ExtendedNamespaceContext namespaceContext = xw.getNamespaceContext();
		if (namespaceContext != null) {
			// get the list of all namespace prefixes
			Iterator<String> prefixIt = namespaceContext.getAllPrefixes();
			while (prefixIt.hasNext()) {
				String prefix = prefixIt.next();
				String namespaceURI = namespaceContext.getNamespaceURI(prefix);
				if (prefix == null ||  prefix.equals(XMLConstants.DEFAULT_NS_PREFIX)) {
					returnString.append(" xmlns=\"" + namespaceURI + "\"");
				} else {
					returnString.append(" xmlns:" + prefix + "=\"" + namespaceURI + "\"");
				}
			}
			
		}
		return returnString.toString();
	}
	
	
	
	
	/**
	 * Convert the {@link com.att.research.xacml.api.Response} object into a string suitable for output in an HTTPResponse.
	 * This method generates the output without any pretty-printing.
	 * This is the method normally called by the Web Service for generating the output to the PEP through the RESTful interface.
	 * 
	 * @param response Response to convert
	 * @param outputStream OutputStream to send conversion
	 * @throws IOException IO Exception
	 * @throws DOMStructureException Structure exception
	 */
	public static void convert(Response response, OutputStream outputStream) throws IOException, DOMStructureException {
		convert(response, outputStream, false);
	}
	
	/**
	 * Do the work of converting the {@link com.att.research.xacml.api.Response} object to a string, allowing for pretty-printing if desired.
	 * 
     * @param response Response to convert
     * @param outputStream OutputStream to send conversion
	 * @param prettyPrint <code>true</code> if pretty printing
     * @throws IOException IO Exception
     * @throws DOMStructureException Structure exception
	 */
	public static void convert(Response response, OutputStream outputStream, boolean prettyPrint) throws IOException, DOMStructureException {
		
		OutputStreamWriter osw = new OutputStreamWriter(outputStream);
		
		if (response == null) {
			throw new DOMStructureException("No Request in convert");
		}
		
		if (response.getResults() == null || response.getResults().isEmpty()) {
			// must be at least one result
			throw new DOMStructureException("No Result in Response");
		}
		
		
		StringBuilder sb = new StringBuilder();
		
		sb.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
		
		if (prettyPrint) sb.append("\n");
		
		// response with attributes
		sb.append("<Response");
		
//TODO include all Namespace info
// Currently this is hard-coded for just the standard XACML namespaces, but ideally should use Namespaces from incoming Request to get non-standard ones.
		sb.append(" xmlns=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\"");
		sb.append(" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"");
		sb.append(" xsi:schemaLocation=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17");
        sb.append(" http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd\"");
        
        // end of <Response>
        sb.append(">");
				
		// for each Result...
		for (Result result : response.getResults()) {
			
			if (prettyPrint) sb.append("\n\t");
			
			sb.append("<Result>");
			
			// Decision
			if (prettyPrint) sb.append("\n\t\t");
			
			if (result.getDecision() == null) {
				throw new DOMStructureException("Result missing Decision");
			}
			sb.append("<Decision>" + result.getDecision().toString() + "</Decision>");
			
			// Status
			Status status = result.getStatus();
			if (status != null) {
				if (prettyPrint) sb.append("\n\t\t");
				sb.append("<Status>");
				
				// status code
				StatusCode statusCode = status.getStatusCode();
				Identifier statusCodeId;
				if (statusCode == null) {
					throw new DOMStructureException("Status must have StatusCode");
				} else {
					statusCodeId = statusCode.getStatusCodeValue();
		 			// if there is a status code, it must agree with the decision
	    			// Permit/Deny/NotAllowed must all be OK
	    			// Indeterminate must not be OK
	    			if ( (statusCodeId.equals(StdStatusCode.STATUS_CODE_OK.getStatusCodeValue())  &&
	    					! (result.getDecision() == Decision.DENY || result.getDecision() == Decision.PERMIT || result.getDecision() == Decision.NOTAPPLICABLE))  ||
	    				( ! statusCodeId.equals(StdStatusCode.STATUS_CODE_OK.getStatusCodeValue())  &&
	    	    					! (result.getDecision() == Decision.INDETERMINATE || result.getDecision() == Decision.INDETERMINATE_DENY || 
	    	    						result.getDecision() == Decision.INDETERMINATE_DENYPERMIT || result.getDecision() == Decision.INDETERMINATE_PERMIT ))  )
	    					{
	    				throw new DOMStructureException("StatusCode '" + statusCodeId.stringValue() + "' does not match Decision '" + result.getDecision().toString());
	    			}
					
					
					outputStatusCode(sb, statusCode, 3, prettyPrint);
				}
				
				// status message
				if (status.getStatusMessage() != null) {
	
					if (prettyPrint) sb.append("\n\t\t\t");
					sb.append("<StatusMessage>" + status.getStatusMessage() + "</StatusMessage>");

				}
				
				// status detail
				StatusDetail statusDetail = status.getStatusDetail();
				if (statusDetail != null) {
	    			// cross-check that rules defined in XACML Core spec section 5.5.7 re: when StatusDetail may/may-not be included have been followed
	    			if (status.isOk()) {
	    				throw new DOMStructureException("Status '" + statusCodeId.stringValue() + "' must not return StatusDetail");
	    			} else if (statusCodeId.stringValue().equals(XACML3.ID_STATUS_MISSING_ATTRIBUTE.stringValue()) && 
	    					status.getStatusDetail().getMissingAttributeDetails() == null) {
	    				throw new DOMStructureException("Status '" + statusCodeId.stringValue() + "' has StatusDetail without MissingAttributeDetail");
	    			} else if (statusCodeId.stringValue().equals(XACML3.ID_STATUS_SYNTAX_ERROR.stringValue()))  {
	    				throw new DOMStructureException("Status '" + statusCodeId.stringValue() + "' must not return StatusDetail");
	    			} else if (statusCodeId.stringValue().equals(XACML3.ID_STATUS_PROCESSING_ERROR.stringValue()))  {
	    				throw new DOMStructureException("Status '" + statusCodeId.stringValue() + "' must not return StatusDetail");
	    			}
	    			
	    			// if included, StatusDetail is handled differently for each type of detail message and the contents are formatted into escaped XML rather than objects
	    			
	    			if (result.getStatus().getStatusDetail().getMissingAttributeDetails() != null) {
						if (prettyPrint) sb.append("\n\t\t\t");
						sb.append("<StatusDetail>");
						
						for (MissingAttributeDetail mad : statusDetail.getMissingAttributeDetails()) {
							if (mad.getAttributeId() == null || mad.getCategory() == null || mad.getDataTypeId() == null) {
								throw new DOMStructureException("MissingAttributeDetail is missing required AttributeId, Category or DataTypeId");
							}
							if (prettyPrint) sb.append("\n\t\t\t\t");
							sb.append("<MissingAttributeDetail");
							sb.append(" Category=\"" + mad.getCategory().stringValue() + "\"");
							sb.append(" AttributeId=\"" + mad.getAttributeId().stringValue() + "\"");
							sb.append(" DataTypeId=\"" + mad.getDataTypeId().stringValue() + "\"");
							if (mad.getIssuer() != null) {
								sb.append(" Issuer=\"" + mad.getIssuer() + "\"");
							}
							sb.append(">");
							if (mad.getAttributeValues() != null) {
								for (AttributeValue<?> value : mad.getAttributeValues()) {
									if (prettyPrint) {
										sb.append("\n\t\t\t\t\t");
									}
									sb.append("<AttributeValue" + getNamespaces(value.getValue()) + ">" + outputValueValue(value.getValue()) + "</AttributeValue>");
								}
							}
							if (prettyPrint) {
								sb.append("\n\t\t\t\t");
							}
							sb.append("</MissingAttributeDetail>");
						}
						
						if (prettyPrint) {
							sb.append("\n\t\t\t");
						}
						sb.append("</StatusDetail>");
	    			}
				}
				
				if (prettyPrint) sb.append("\n\t\t");
				sb.append("</Status>");
			}
			
			// Obligations
			if (result.getObligations() != null && ! result.getObligations().isEmpty()) {
				if (prettyPrint) sb.append("\n\t\t");
				sb.append("<Obligations>");
				
				for (Obligation obligation : result.getObligations()) {
					if (obligation.getId() == null) {
						throw new DOMStructureException("Obligation must have ObligationId");
					}
					if (prettyPrint) sb.append("\n\t\t\t");
					sb.append("<Obligation ObligationId=\"" + obligation.getId().stringValue() + "\">");
					
					for (AttributeAssignment aa : obligation.getAttributeAssignments()) {
						if (prettyPrint) sb.append("\n\t\t\t\t");
						sb.append("<AttributeAssignment");
						
						if (aa.getAttributeId() == null) {
							throw new DOMStructureException("Obligation AttributeAssignment must have AttributeId");
						}
						sb.append(" AttributeId=\"" + aa.getAttributeId().stringValue() + "\"");
						if (aa.getDataTypeId() == null || aa.getAttributeValue() == null || aa.getAttributeValue().getValue() == null) {
							throw new DOMStructureException("Obligation AttributeAssignment '" + aa.getAttributeId().stringValue() + "' must have DataType and Value");
						}
						sb.append(" DataType=\"" + aa.getDataTypeId().stringValue() + "\"" + getNamespaces(aa.getAttributeValue().getValue()) + ">");
						sb.append(outputValueValue(aa.getAttributeValue().getValue()));

						sb.append("</AttributeAssignment>");
					}
					
					if (prettyPrint) sb.append("\n\t\t\t");
					sb.append("</Obligation>");
				}
				
				if (prettyPrint) sb.append("\n\t\t");
				sb.append("</Obligations>");
			}
			
			// AssociatedAdvice
			if (result.getAssociatedAdvice() != null && ! result.getAssociatedAdvice().isEmpty()) {
				if (prettyPrint) sb.append("\n\t\t");
				sb.append("<AssociatedAdvice>");
				
				for (Advice advice : result.getAssociatedAdvice()) {
					if (advice.getId() == null) {
						throw new DOMStructureException("Advice must have AdviceId");
					}
					if (prettyPrint) sb.append("\n\t\t\t");
					sb.append("<Advice AdviceId=\"" + advice.getId().stringValue() + "\">");
					
					for (AttributeAssignment aa : advice.getAttributeAssignments()) {
						if (prettyPrint) sb.append("\n\t\t\t\t");
						sb.append("<AttributeAssignment");
						
						if (aa.getAttributeId() == null) {
							throw new DOMStructureException("Advice AttributeAssignment must have AttributeId");
						}
						sb.append(" AttributeId=\"" + aa.getAttributeId().stringValue() + "\"");
						if (aa.getDataTypeId() == null || aa.getAttributeValue() == null || aa.getAttributeValue().getValue() == null) {
							throw new DOMStructureException("Advice AttributeAssignment '" + aa.getAttributeId().stringValue() + "' must have DataType and Value");
						}
						sb.append(" DataType=\"" + aa.getDataTypeId().stringValue() + "\"" + getNamespaces(aa.getAttributeValue().getValue()) + ">");
						sb.append(outputValueValue(aa.getAttributeValue().getValue()));

						sb.append("</AttributeAssignment>");
					}
					
					if (prettyPrint) sb.append("\n\t\t\t");
					sb.append("</Advice>");
				}
				
				if (prettyPrint) sb.append("\n\t\t");
				sb.append("</AssociatedAdvice>");
			}
			
			// Attributes
			if (result.getAttributes() != null && ! result.getAttributes().isEmpty()) {
				// this may include attributes with IncludeInResult=false!

				
				for (AttributeCategory category : result.getAttributes()) {
					if (prettyPrint) sb.append("\n\t\t");
					if (category.getCategory() == null) {
						throw new DOMStructureException("Attributes must have Category");
					}
					sb.append("<Attributes Category=\"" + category.getCategory().stringValue() + "\">");
					
					for (Attribute attr : category.getAttributes()) {
						if (! attr.getIncludeInResults()) {
							// skip this one - do not include in results
							continue;
						}
						if (prettyPrint) sb.append("\n\t\t\t");
						sb.append("<Attribute IncludeInResult=\""+ attr.getIncludeInResults()+"\"");
						if (attr.getAttributeId() == null) {
							throw new DOMStructureException("Attribute inf Category '" + category.getCategory().stringValue() + "' must have AttributeId");
						}
						sb.append(" AttributeId=\"" + attr.getAttributeId().stringValue() + "\"");
						if (attr.getIssuer() == null) {
							sb.append(">");
						} else {
							sb.append(" Issuer=\"" + attr.getIssuer() + "\">");
						}
						
						if (attr.getValues().isEmpty()) {
							throw new DOMStructureException("Attribute '" + attr.getAttributeId() + "' must have at least one value");
						}
						for (AttributeValue<?> value : attr.getValues()) {
							if (value.getDataTypeId() == null || value.getValue() == null) {
								throw new DOMStructureException("Attribute '" + attr.getAttributeId() + "' has AttributeValue missing either DataType or Value");
							}
							if (prettyPrint) sb.append("\n\t\t\t\t");
							sb.append("<AttributeValue DataType=\"" + value.getDataTypeId().stringValue() + "\"");
							if (value.getXPathCategory() != null) {
								sb.append(" XPathCategory=\"" + value.getXPathCategory().stringValue() + "\"");
							}
							sb.append(">");
							
							sb.append(outputValueValue(value.getValue()));
							
							
							sb.append("</AttributeValue>");
						}
						
						if (prettyPrint) sb.append("\n\t\t\t");
						sb.append("</Attribute>");
					}
					
					if (prettyPrint) sb.append("\n\t\t");
					sb.append("</Attributes>");
				}
				
			}
			
			
			// PolicyIdentifierList
			Collection<IdReference> policyIds = result.getPolicyIdentifiers();
			Collection<IdReference> policySetIds = result.getPolicySetIdentifiers();
			if (policyIds != null && ! policyIds.isEmpty() || policySetIds != null && ! policySetIds.isEmpty()) {
				if (prettyPrint) sb.append("\n\t\t\t");
				sb.append("<PolicyIdentifierList>");
				
				// individual Ids
				for (IdReference idReference : policyIds) {
					if (idReference == null) {
						throw new DOMStructureException("PolicyIdentifiers has null IdReference");
					}
					if (prettyPrint) sb.append("\n\t\t\t\t");
					sb.append("<PolicyIdReference");
					if (idReference.getVersion() != null) {
						sb.append(" Version=\"" + idReference.getVersion().stringValue() + "\">");
					} else {
						sb.append(">");
					}
					sb.append(idReference.getId().stringValue());
					sb.append("</PolicyIdReference>");		
				}
				// Set Ids
				for (IdReference idReference : policySetIds) {
					if (idReference == null) {
						throw new DOMStructureException("PolicySetIdentifiers has null IdReference");
					}
					if (prettyPrint) sb.append("\n\t\t\t\t");
					sb.append("<PolicySetIdReference");
					if (idReference.getVersion() != null) {
						sb.append(" Version=\"" + idReference.getVersion().stringValue() + "\">");
					} else {
						sb.append(">");
					}
					sb.append(idReference.getId().stringValue());
					sb.append("</PolicySetIdReference>");		
				}
				
				if (prettyPrint) sb.append("\n\t\t\t");
				sb.append("</PolicyIdentifierList>");
			}
			
			
			
			// end of Result
			if (prettyPrint) sb.append("\n\t");
			sb.append("</Result>");
		}
		
		if (prettyPrint) sb.append("\n");
		
		sb.append("</Response>");
		
		// all done
		
		osw.write(sb.toString());
		
		// force output
		osw.flush();

	}
	
	/**
	 * Unit test program to load an XML file containing a XACML Response document. This should only
	 * be used in a local testing environment and not in production.
	 * 
	 * @param args the list of Response files to load and parse
	 * @throws ParserConfigurationException Parser configuration exception
	 */
	public static void main(String[] args) throws ParserConfigurationException { //NOSONAR
        Collection<String> santized = MainUtils.santizeArguments(args);
        if (santized.isEmpty()) {
            return;
        }
		DocumentBuilderFactory	documentBuilderFactory	= DocumentBuilderFactory.newInstance();
        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
        documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
		documentBuilderFactory.setNamespaceAware(true);
		for (String xmlFileName: santized) {
			File	fileXml	= new File(xmlFileName);
            if (!fileXml.exists() || !fileXml.canRead()) {
                logger.error("Input file \"{}\\\" does not exist or is unreadable.", fileXml.getAbsolutePath());
                continue;
            }
			logger.debug("{}:", fileXml.getAbsolutePath());
			try {
				DocumentBuilder	documentBuilder	= documentBuilderFactory.newDocumentBuilder();
				assert(documentBuilder.isNamespaceAware());
				Document documentResponse		= documentBuilder.parse(fileXml);
				assert(documentResponse != null);
				
				NodeList children				= documentResponse.getChildNodes();
				if (children == null || children.getLength() == 0) {
					logger.error("No Responses found in \"{}\\\"", fileXml.getAbsolutePath());
					continue;
				} else if (children.getLength() > 1) {
					logger.error("Multiple Responses found in \"{}\\\"", fileXml.getAbsolutePath());
				}
				Node nodeResponse				= children.item(0);
				if (!nodeResponse.getLocalName().equals(XACML3.ELEMENT_RESPONSE)) {
					logger.error("\"{}\\\" is not a Response", fileXml.getAbsolutePath());
					continue;
				}
				
				Response domResponse			= DOMResponse.newInstance(nodeResponse);
				logger.debug("{}", domResponse);
			} catch (Exception ex) {
				logger.error("Processing exception", ex);
			}
		}
	}

}
